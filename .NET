using System;
using System.Net.Http;
using System.Threading.Tasks;
using System.Web;
using Newtonsoft.Json;

// Configuration class to store OAuth credentials
public static class OAuthConfig
{
    public static string ClientId { get; set; }
    public static string ClientSecret { get; set; }
}

// Static class to hold the constant URLs used in the OAuth process
public class ConstUrls
{
    public const string AuthUrl = "https://launchpad.classlink.com/oauth2/v2/auth";
    public const string ExchangeUrl = "https://launchpad.classlink.com/oauth2/v2/token";
    public const string InfoUrl = "https://nodeapi.classlink.com/";
}

// Service class to handle OAuth operations
public class OAuthService
{
    // HttpClient is intended to be instantiated once and re-used throughout the life of an application.
    private static readonly HttpClient httpClient = new HttpClient();

    // Set the configuration with client ID and client secret
    public static void SetConfig(string clientId, string clientSecret)
    {
        if (string.IsNullOrEmpty(clientId) || string.IsNullOrEmpty(clientSecret))
        {
            throw new ArgumentException("Client ID and Client Secret must be non-empty strings.");
        }

        OAuthConfig.ClientId = clientId;
        OAuthConfig.ClientSecret = clientSecret;
    }

    // Generate the URL needed to get the authorization code from the authorization server
    public static string GetCodeUrl(string scope = "profile", string redirectUri = "http://localhost:8080/code")
    {
        if (string.IsNullOrEmpty(OAuthConfig.ClientId))
        {
            throw new InvalidOperationException("Configuration not set. Call SetConfig before requesting the URL.");
        }

        var query = HttpUtility.ParseQueryString(string.Empty);
        query["client_id"] = OAuthConfig.ClientId;
        query["scope"] = scope;
        query["redirect_uri"] = redirectUri;
        query["response_type"] = "code";

        return $"{ConstUrls.AuthUrl}?{query}";
    }

    // Asynchronously get the access token using the authorization code
    public static async Task<string> GetTokenAsync(string code)
    {
        if (string.IsNullOrEmpty(OAuthConfig.ClientId) || string.IsNullOrEmpty(OAuthConfig.ClientSecret))
        {
            throw new InvalidOperationException("Configuration not set. Call SetConfig before requesting the token.");
        }

        if (string.IsNullOrEmpty(code))
        {
            throw new ArgumentException("Code must be a non-empty string.");
        }

        var content = new FormUrlEncodedContent(new[]
        {
            new KeyValuePair<string, string>("client_id", OAuthConfig.ClientId),
            new KeyValuePair<string, string>("client_secret", OAuthConfig.ClientSecret),
            new KeyValuePair<string, string>("code", code)
        });

        var response = await httpClient.PostAsync(ConstUrls.ExchangeUrl, content);
        response.EnsureSuccessStatusCode();

        var responseContent = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<dynamic>(responseContent).access_token;
    }

    // Asynchronously make an API request to the specified endpoint and optionally extract specific nodes from the JSON response
    public static async Task<dynamic> GetInfoAsync(string bearer, string endpoint, string[] extractNode = null)
    {
        if (string.IsNullOrEmpty(bearer) || string.IsNullOrEmpty(endpoint))
        {
            throw new ArgumentException("Bearer token and endpoint must be non-empty strings.");
        }

        var request = new HttpRequestMessage(HttpMethod.Get, $"{ConstUrls.InfoUrl}{endpoint}");
        request.Headers.Add("Authorization", $"Bearer {bearer}");

        var response = await httpClient.SendAsync(request);
        response.EnsureSuccessStatusCode();

        var content = await response.Content.ReadAsStringAsync();
        var jsonContent = JsonConvert.DeserializeObject<dynamic>(content);

        if (extractNode == null)
        {
            return jsonContent;
        }

        var result = new Newtonsoft.Json.Linq.JObject();
        foreach (var node in extractNode)
        {
            if (jsonContent[node] != null)
            {
                result[node] = jsonContent[node];
            }
        }

        return result;
    }
}
